// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

package providers

import (
	"context"
	"encoding/json"
	"fmt"

	"k8s.io/apimachinery/pkg/api/errors"

	rke2cpv1beta1 "github.com/rancher/cluster-api-provider-rke2/controlplane/api/v1beta1"
	corev1 "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	capiv1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
	dockerv1beta1 "sigs.k8s.io/cluster-api/test/infrastructure/docker/api/v1beta1"
	"sigs.k8s.io/controller-runtime/pkg/client"
)

type rke2docker struct {
}

func (rke2docker) CreateControlPlaneTemplate(ctx context.Context, c client.Client, name types.NamespacedName, config string) error {
	var cpt rke2cpv1beta1.RKE2ControlPlaneTemplate
	if err := json.Unmarshal([]byte(config), &cpt); err != nil {
		return fmt.Errorf("failed to unmarshal control plane template: %w", err)
	}

	cpt.ObjectMeta = metav1.ObjectMeta{
		Name:      name.Name,
		Namespace: name.Namespace,
	}

	cpt.Spec.Template.Spec.InfrastructureRef = corev1.ObjectReference{
		APIVersion: "infrastructure.cluster.x-k8s.io/v1beta1",
		Kind:       DockerMachineTemplate,
		Name:       fmt.Sprintf("%s-controlplane", name.Name),
	}

	return c.Create(ctx, &cpt)
}

func (rd rke2docker) CreateControlPlaneMachineTemplate(ctx context.Context, c client.Client, name types.NamespacedName) error {
	cpmt := dockerv1beta1.DockerMachineTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:      fmt.Sprintf("%s-controlplane", name.Name),
			Namespace: name.Namespace,
		},
		Spec: dockerv1beta1.DockerMachineTemplateSpec{
			Template: dockerv1beta1.DockerMachineTemplateResource{
				Spec: dockerv1beta1.DockerMachineSpec{
					CustomImage: "kindest/node:v1.30.3-custom",
					ExtraMounts: []dockerv1beta1.Mount{
						{ContainerPath: "/var/run/docker.sock", HostPath: "/var/run/docker.sock"},
					},
				},
			},
		},
	}
	return c.Create(ctx, &cpmt)
}

func (rd rke2docker) CreateClusterTemplate(ctx context.Context, c client.Client, name types.NamespacedName) error {
	ct := dockerv1beta1.DockerClusterTemplate{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name.Name,
			Namespace: name.Namespace,
		},
		Spec: dockerv1beta1.DockerClusterTemplateSpec{
			Template: dockerv1beta1.DockerClusterTemplateResource{
				Spec: dockerv1beta1.DockerClusterSpec{
					LoadBalancer: dockerv1beta1.DockerLoadBalancer{
						CustomHAProxyConfigTemplateRef: &corev1.LocalObjectReference{
							Name: fmt.Sprintf("%s-rke2-class-lb-config", name.Name),
						},
					},
				},
			},
		},
	}
	return c.Create(ctx, &ct)
}

func (rd rke2docker) CreatePrerequisites(ctx context.Context, c client.Client, name types.NamespacedName) error {
	name.Name = name.Name + "-rke2-class-lb-config"

	configMap := &corev1.ConfigMap{
		ObjectMeta: metav1.ObjectMeta{
			Name:      name.Name,
			Namespace: name.Namespace,
		},
		Data: map[string]string{
			"value": `# generated by kind
global
  log /dev/log local0
  log /dev/log local1 notice
  daemon
  # limit memory usage to approximately 18 MB
  # (see https://github.com/kubernetes-sigs/kind/pull/3115)
  maxconn 100000

resolvers docker
  nameserver dns 127.0.0.11:53

defaults
  log global
  mode tcp
  option dontlognull
  # TODO: tune these
  timeout connect 5000
  timeout client 50000
  timeout server 50000
  # allow to boot despite dns don't resolve backends
  default-server init-addr none

frontend stats
  bind *:8404
  stats enable
  stats uri /
  stats refresh 10s

frontend control-plane
  bind *:{{ .FrontendControlPlanePort }}
  {{ if .IPv6 -}}
  bind :::{{ .FrontendControlPlanePort }};
  {{- end }}
  default_backend kube-apiservers

backend kube-apiservers
  option httpchk GET /healthz
  http-check expect status 401
  # TODO: we should be verifying (!)
  {{range $server, $address := .BackendServers}}
  server {{ $server }} {{ JoinHostPort $address $.BackendControlPlanePort }} check check-ssl verify none resolvers docker resolve-prefer {{ if $.IPv6 -}} ipv6 {{- else -}} ipv4 {{- end }}
  {{- end}}

frontend rke2-join
  bind *:9345
  {{ if .IPv6 -}}
  bind :::9345;
  {{- end }}
  default_backend rke2-servers

backend rke2-servers
  option httpchk GET /v1-rke2/readyz
  http-check expect status 403
  {{range $server, $address := .BackendServers}}
  server {{ $server }} {{ $address }}:9345 check check-ssl verify none
  {{- end}}`,
		},
	}

	return c.Create(ctx, configMap)
}

func (rke2docker) DeletePrerequisites(ctx context.Context, c client.Client, name types.NamespacedName) error {
	cm := &corev1.ConfigMap{}
	err := c.Get(ctx, types.NamespacedName{Name: fmt.Sprintf("%s-rke2-class-lb-config", name.Name), Namespace: name.Namespace}, cm)
	switch {
	// ignore error if ConfigMap is not found (already deleted)
	case err != nil && errors.IsNotFound(err):
		return nil
	case err != nil:
		return err
	default:
		return c.Delete(ctx, cm)
	}
}

func (rke2docker) GetPrerequisites(ctx context.Context, c client.Client, name types.NamespacedName) error {
	return c.Get(ctx, types.NamespacedName{Name: fmt.Sprintf("%s-rke2-class-lb-config", name.Name), Namespace: name.Namespace}, &corev1.ConfigMap{})
}

func (rd rke2docker) GetControlPlaneTemplate(ctx context.Context, c client.Client, name types.NamespacedName) error {
	return c.Get(ctx, name, &rke2cpv1beta1.RKE2ControlPlaneTemplate{})
}

func (kd rke2docker) GetControlPlaneMachineTemplate(ctx context.Context, c client.Client, name types.NamespacedName) error {
	return c.Get(ctx, types.NamespacedName{Name: name.Name + "-controlplane", Namespace: name.Namespace}, &dockerv1beta1.DockerMachineTemplate{})

}

func (kd rke2docker) GetClusterTemplate(ctx context.Context, c client.Client, name types.NamespacedName) error {
	return c.Get(ctx, name, &dockerv1beta1.DockerClusterTemplate{})
}

func (rd rke2docker) AlterClusterClass(cc *capiv1beta1.ClusterClass) {
	cc.Spec.ControlPlane.LocalObjectTemplate.Ref.Kind = RKE2ControlPlaneTemplate
	cc.Spec.ControlPlane.MachineInfrastructure.Ref.Kind = DockerMachineTemplate
	cc.Spec.Infrastructure.Ref.Kind = DockerClusterTemplate
}
