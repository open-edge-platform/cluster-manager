// Code generated by mockery. DO NOT EDIT.

package k8s

import (
	"context"

	intelProvider "github.com/open-edge-platform/cluster-api-provider-intel/api/v1alpha1"
	v1alpha1 "github.com/open-edge-platform/cluster-manager/v2/api/v1alpha1"
	"github.com/stretchr/testify/mock"
	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"
	capi "sigs.k8s.io/cluster-api/api/v1beta1"
	dockerProvider "sigs.k8s.io/cluster-api/test/infrastructure/docker/api/v1beta1"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// StartInformers provides a mock function with given fields: ctx, resources
func (_m *MockClient) StartInformers(ctx context.Context, resources []schema.GroupVersionResource) error {
	ret := _m.Called(ctx, resources)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []schema.GroupVersionResource) error); ok {
		r0 = rf(ctx, resources)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// GetCached provides a mock function with given fields: ctx, resourceSchema, namespace, name
func (_m *MockClient) GetCached(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace, name string) (*unstructured.Unstructured, error) {
	ret := _m.Called(ctx, resourceSchema, namespace, name)

	var r0 *unstructured.Unstructured
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, string) (*unstructured.Unstructured, error)); ok {
		return rf(ctx, resourceSchema, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, string) *unstructured.Unstructured); ok {
		r0 = rf(ctx, resourceSchema, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*unstructured.Unstructured)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.GroupVersionResource, string, string) error); ok {
		r1 = rf(ctx, resourceSchema, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListCached provides a mock function with given fields: ctx, resourceSchema, namespace, listOptions
func (_m *MockClient) ListCached(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace string, listOptions v1.ListOptions) (*unstructured.UnstructuredList, error) {
	ret := _m.Called(ctx, resourceSchema, namespace, listOptions)

	var r0 *unstructured.UnstructuredList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) (*unstructured.UnstructuredList, error)); ok {
		return rf(ctx, resourceSchema, namespace, listOptions)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) *unstructured.UnstructuredList); ok {
		r0 = rf(ctx, resourceSchema, namespace, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*unstructured.UnstructuredList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) error); ok {
		r1 = rf(ctx, resourceSchema, namespace, listOptions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateNamespace provides a mock function with given fields: ctx, name
func (_m *MockClient) CreateNamespace(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteNamespace provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteNamespace(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTemplate provides a mock function with given fields: ctx, namespace, template
func (_m *MockClient) CreateTemplate(ctx context.Context, namespace string, template *v1alpha1.ClusterTemplate) error {
	ret := _m.Called(ctx, namespace, template)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *v1alpha1.ClusterTemplate) error); ok {
		r0 = rf(ctx, namespace, template)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateCluster provides a mock function with given fields: ctx, namespace, cluster
func (_m *MockClient) CreateCluster(ctx context.Context, namespace string, cluster capi.Cluster) (string, error) {
	ret := _m.Called(ctx, namespace, cluster)

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, capi.Cluster) (string, error)); ok {
		return rf(ctx, namespace, cluster)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, capi.Cluster) string); ok {
		r0 = rf(ctx, namespace, cluster)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, capi.Cluster) error); ok {
		r1 = rf(ctx, namespace, cluster)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteClusters provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteClusters(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteTemplates provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteTemplates(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateClusterLabels provides a mock function with given fields: ctx, namespace, clusterName, newLabels
func (_m *MockClient) CreateClusterLabels(ctx context.Context, namespace string, clusterName string, newLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, clusterName, newLabels)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, clusterName, newLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// CreateTemplateLabels provides a mock function with given fields: ctx, namespace, templateName, newLabels
func (_m *MockClient) CreateTemplateLabels(ctx context.Context, namespace string, templateName string, newLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, templateName, newLabels)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, templateName, newLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DefaultTemplate provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DefaultTemplate(ctx context.Context, namespace string) (v1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace)

	var r0 v1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (v1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) v1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Get(0).(v1alpha1.ClusterTemplate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Templates provides a mock function with given fields: ctx, namespace
func (_m *MockClient) Templates(ctx context.Context, namespace string) ([]v1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace)

	var r0 []v1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]v1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []v1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1alpha1.ClusterTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Template provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) Template(ctx context.Context, namespace, name string) (v1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 v1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (v1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) v1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		r0 = ret.Get(0).(v1alpha1.ClusterTemplate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetCluster provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetCluster(ctx context.Context, namespace, name string) (*capi.Cluster, error) {
	ret := _m.Called(ctx, namespace, name)

	var r0 *capi.Cluster
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*capi.Cluster, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *capi.Cluster); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*capi.Cluster)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) GetMachines(ctx context.Context, namespace, clusterName string) ([]capi.Machine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	var r0 []capi.Machine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]capi.Machine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []capi.Machine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]capi.Machine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateMachineBinding provides a mock function with given fields: ctx, namespace, binding
func (_m *MockClient) CreateMachineBinding(ctx context.Context, namespace string, binding intelProvider.IntelMachineBinding) error {
	ret := _m.Called(ctx, namespace, binding)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, intelProvider.IntelMachineBinding) error); ok {
		r0 = rf(ctx, namespace, binding)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// IntelMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) IntelMachines(ctx context.Context, namespace, clusterName string) ([]intelProvider.IntelMachine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	var r0 []intelProvider.IntelMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]intelProvider.IntelMachine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []intelProvider.IntelMachine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]intelProvider.IntelMachine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) DockerMachines(ctx context.Context, namespace, clusterName string) ([]dockerProvider.DockerMachine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	var r0 []dockerProvider.DockerMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]dockerProvider.DockerMachine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []dockerProvider.DockerMachine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]dockerProvider.DockerMachine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IntelMachine provides a mock function with given fields: ctx, namespace, providerMachineName
func (_m *MockClient) IntelMachine(ctx context.Context, namespace, providerMachineName string) (intelProvider.IntelMachine, error) {
	ret := _m.Called(ctx, namespace, providerMachineName)

	var r0 intelProvider.IntelMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (intelProvider.IntelMachine, error)); ok {
		return rf(ctx, namespace, providerMachineName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) intelProvider.IntelMachine); ok {
		r0 = rf(ctx, namespace, providerMachineName)
	} else {
		r0 = ret.Get(0).(intelProvider.IntelMachine)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, providerMachineName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DockerMachine provides a mock function with given fields: ctx, namespace, providerMachineName
func (_m *MockClient) DockerMachine(ctx context.Context, namespace, providerMachineName string) (dockerProvider.DockerMachine, error) {
	ret := _m.Called(ctx, namespace, providerMachineName)

	var r0 dockerProvider.DockerMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (dockerProvider.DockerMachine, error)); ok {
		return rf(ctx, namespace, providerMachineName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) dockerProvider.DockerMachine); ok {
		r0 = rf(ctx, namespace, providerMachineName)
	} else {
		r0 = ret.Get(0).(dockerProvider.DockerMachine)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, providerMachineName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Dynamic provides a mock function with given fields:
func (_m *MockClient) Dynamic() dynamic.Interface {
	ret := _m.Called()

	var r0 dynamic.Interface
	if rf, ok := ret.Get(0).(func() dynamic.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dynamic.Interface)
		}
	}

	return r0
}

// GetMachineByHostID provides a mock function with given fields: ctx, namespace, hostID
func (_m *MockClient) GetMachineByHostID(ctx context.Context, namespace, hostID string) (capi.Machine, error) {
	ret := _m.Called(ctx, namespace, hostID)

	var r0 capi.Machine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (capi.Machine, error)); ok {
		return rf(ctx, namespace, hostID)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) capi.Machine); ok {
		r0 = rf(ctx, namespace, hostID)
	} else {
		r0 = ret.Get(0).(capi.Machine)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, hostID)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteCluster provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) DeleteCluster(ctx context.Context, namespace, clusterName string) error {
	ret := _m.Called(ctx, namespace, clusterName)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) error); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// SetMachineLabels provides a mock function with given fields: ctx, namespace, machineName, newUserLabels
func (_m *MockClient) SetMachineLabels(ctx context.Context, namespace, machineName string, newUserLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, machineName, newUserLabels)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, machineName, newUserLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// WithInClusterConfig provides a mock function with given fields:
func (_m *MockClient) WithInClusterConfig() *ManagerClient {
	ret := _m.Called()

	var r0 *ManagerClient
	if rf, ok := ret.Get(0).(func() *ManagerClient); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*ManagerClient)
		}
	}

	return r0
}

// CreateSecret provides a mock function with given fields: ctx, namespace, name, data
func (_m *MockClient) CreateSecret(ctx context.Context, namespace, name string, data map[string][]byte) error {
	ret := _m.Called(ctx, namespace, name, data)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string][]byte) error); ok {
		r0 = rf(ctx, namespace, name, data)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// RemoveTemplateLabels provides a mock function with given fields: ctx, namespace, templateName, labelKeys
func (_m *MockClient) RemoveTemplateLabels(ctx context.Context, namespace, templateName string, labelKeys ...string) error {
	args := []interface{}{ctx, namespace, templateName}
	for _, key := range labelKeys {
		args = append(args, key)
	}
	ret := _m.Called(args...)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, ...string) error); ok {
		r0 = rf(ctx, namespace, templateName, labelKeys...)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// AddTemplateLabels provides a mock function with given fields: ctx, namespace, templateName, newLabels
func (_m *MockClient) AddTemplateLabels(ctx context.Context, namespace, templateName string, newLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, templateName, newLabels)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, templateName, newLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// HasTemplate provides a mock function with given fields: ctx, namespace, templateName
func (_m *MockClient) HasTemplate(ctx context.Context, namespace, templateName string) bool {
	ret := _m.Called(ctx, namespace, templateName)

	var r0 bool
	if rf, ok := ret.Get(0).(func(context.Context, string, string) bool); ok {
		r0 = rf(ctx, namespace, templateName)
	} else {
		r0 = ret.Get(0).(bool)
	}

	return r0
}

// GetClusterTemplate provides a mock function with given fields: ctx, namespace, templateName
func (_m *MockClient) GetClusterTemplate(ctx context.Context, namespace, templateName string) (*v1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace, templateName)

	var r0 *v1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*v1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace, templateName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *v1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace, templateName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1alpha1.ClusterTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, templateName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// SetClusterLabels provides a mock function with given fields: ctx, namespace, clusterName, newUserLabels
func (_m *MockClient) SetClusterLabels(ctx context.Context, namespace, clusterName string, newUserLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, clusterName, newUserLabels)

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, clusterName, newUserLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
