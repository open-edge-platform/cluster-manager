// Code generated by mockery v2.52.2. DO NOT EDIT.

package k8s

import (
	apiv1alpha1 "github.com/open-edge-platform/cluster-manager/v2/api/v1alpha1"
	apiv1beta1 "sigs.k8s.io/cluster-api/test/infrastructure/docker/api/v1beta1"

	context "context"

	dynamic "k8s.io/client-go/dynamic"

	mock "github.com/stretchr/testify/mock"

	schema "k8s.io/apimachinery/pkg/runtime/schema"

	unstructured "k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"

	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"

	v1alpha1 "github.com/open-edge-platform/cluster-api-provider-intel/api/v1alpha1"

	v1beta1 "sigs.k8s.io/cluster-api/api/v1beta1"
)

// MockClient is an autogenerated mock type for the Client type
type MockClient struct {
	mock.Mock
}

type MockClient_Expecter struct {
	mock *mock.Mock
}

func (_m *MockClient) EXPECT() *MockClient_Expecter {
	return &MockClient_Expecter{mock: &_m.Mock}
}

// CreateCluster provides a mock function with given fields: ctx, namespace, cluster
func (_m *MockClient) CreateCluster(ctx context.Context, namespace string, cluster v1beta1.Cluster) (string, error) {
	ret := _m.Called(ctx, namespace, cluster)

	if len(ret) == 0 {
		panic("no return value specified for CreateCluster")
	}

	var r0 string
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, v1beta1.Cluster) (string, error)); ok {
		return rf(ctx, namespace, cluster)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, v1beta1.Cluster) string); ok {
		r0 = rf(ctx, namespace, cluster)
	} else {
		r0 = ret.Get(0).(string)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, v1beta1.Cluster) error); ok {
		r1 = rf(ctx, namespace, cluster)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_CreateCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateCluster'
type MockClient_CreateCluster_Call struct {
	*mock.Call
}

// CreateCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - cluster v1beta1.Cluster
func (_e *MockClient_Expecter) CreateCluster(ctx interface{}, namespace interface{}, cluster interface{}) *MockClient_CreateCluster_Call {
	return &MockClient_CreateCluster_Call{Call: _e.mock.On("CreateCluster", ctx, namespace, cluster)}
}

func (_c *MockClient_CreateCluster_Call) Run(run func(ctx context.Context, namespace string, cluster v1beta1.Cluster)) *MockClient_CreateCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(v1beta1.Cluster))
	})
	return _c
}

func (_c *MockClient_CreateCluster_Call) Return(_a0 string, _a1 error) *MockClient_CreateCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_CreateCluster_Call) RunAndReturn(run func(context.Context, string, v1beta1.Cluster) (string, error)) *MockClient_CreateCluster_Call {
	_c.Call.Return(run)
	return _c
}

// CreateClusterLabels provides a mock function with given fields: ctx, namespace, clusterName, newLabels
func (_m *MockClient) CreateClusterLabels(ctx context.Context, namespace string, clusterName string, newLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, clusterName, newLabels)

	if len(ret) == 0 {
		panic("no return value specified for CreateClusterLabels")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, clusterName, newLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateClusterLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateClusterLabels'
type MockClient_CreateClusterLabels_Call struct {
	*mock.Call
}

// CreateClusterLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - clusterName string
//   - newLabels map[string]string
func (_e *MockClient_Expecter) CreateClusterLabels(ctx interface{}, namespace interface{}, clusterName interface{}, newLabels interface{}) *MockClient_CreateClusterLabels_Call {
	return &MockClient_CreateClusterLabels_Call{Call: _e.mock.On("CreateClusterLabels", ctx, namespace, clusterName, newLabels)}
}

func (_c *MockClient_CreateClusterLabels_Call) Run(run func(ctx context.Context, namespace string, clusterName string, newLabels map[string]string)) *MockClient_CreateClusterLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]string))
	})
	return _c
}

func (_c *MockClient_CreateClusterLabels_Call) Return(_a0 error) *MockClient_CreateClusterLabels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateClusterLabels_Call) RunAndReturn(run func(context.Context, string, string, map[string]string) error) *MockClient_CreateClusterLabels_Call {
	_c.Call.Return(run)
	return _c
}

// CreateMachineBinding provides a mock function with given fields: ctx, namespace, binding
func (_m *MockClient) CreateMachineBinding(ctx context.Context, namespace string, binding v1alpha1.IntelMachineBinding) error {
	ret := _m.Called(ctx, namespace, binding)

	if len(ret) == 0 {
		panic("no return value specified for CreateMachineBinding")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, v1alpha1.IntelMachineBinding) error); ok {
		r0 = rf(ctx, namespace, binding)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateMachineBinding_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateMachineBinding'
type MockClient_CreateMachineBinding_Call struct {
	*mock.Call
}

// CreateMachineBinding is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - binding v1alpha1.IntelMachineBinding
func (_e *MockClient_Expecter) CreateMachineBinding(ctx interface{}, namespace interface{}, binding interface{}) *MockClient_CreateMachineBinding_Call {
	return &MockClient_CreateMachineBinding_Call{Call: _e.mock.On("CreateMachineBinding", ctx, namespace, binding)}
}

func (_c *MockClient_CreateMachineBinding_Call) Run(run func(ctx context.Context, namespace string, binding v1alpha1.IntelMachineBinding)) *MockClient_CreateMachineBinding_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(v1alpha1.IntelMachineBinding))
	})
	return _c
}

func (_c *MockClient_CreateMachineBinding_Call) Return(_a0 error) *MockClient_CreateMachineBinding_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateMachineBinding_Call) RunAndReturn(run func(context.Context, string, v1alpha1.IntelMachineBinding) error) *MockClient_CreateMachineBinding_Call {
	_c.Call.Return(run)
	return _c
}

// CreateNamespace provides a mock function with given fields: ctx, name
func (_m *MockClient) CreateNamespace(ctx context.Context, name string) error {
	ret := _m.Called(ctx, name)

	if len(ret) == 0 {
		panic("no return value specified for CreateNamespace")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, name)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateNamespace'
type MockClient_CreateNamespace_Call struct {
	*mock.Call
}

// CreateNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - name string
func (_e *MockClient_Expecter) CreateNamespace(ctx interface{}, name interface{}) *MockClient_CreateNamespace_Call {
	return &MockClient_CreateNamespace_Call{Call: _e.mock.On("CreateNamespace", ctx, name)}
}

func (_c *MockClient_CreateNamespace_Call) Run(run func(ctx context.Context, name string)) *MockClient_CreateNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_CreateNamespace_Call) Return(_a0 error) *MockClient_CreateNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateNamespace_Call) RunAndReturn(run func(context.Context, string) error) *MockClient_CreateNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTemplate provides a mock function with given fields: ctx, namespace, template
func (_m *MockClient) CreateTemplate(ctx context.Context, namespace string, template *apiv1alpha1.ClusterTemplate) error {
	ret := _m.Called(ctx, namespace, template)

	if len(ret) == 0 {
		panic("no return value specified for CreateTemplate")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, *apiv1alpha1.ClusterTemplate) error); ok {
		r0 = rf(ctx, namespace, template)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTemplate'
type MockClient_CreateTemplate_Call struct {
	*mock.Call
}

// CreateTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - template *apiv1alpha1.ClusterTemplate
func (_e *MockClient_Expecter) CreateTemplate(ctx interface{}, namespace interface{}, template interface{}) *MockClient_CreateTemplate_Call {
	return &MockClient_CreateTemplate_Call{Call: _e.mock.On("CreateTemplate", ctx, namespace, template)}
}

func (_c *MockClient_CreateTemplate_Call) Run(run func(ctx context.Context, namespace string, template *apiv1alpha1.ClusterTemplate)) *MockClient_CreateTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(*apiv1alpha1.ClusterTemplate))
	})
	return _c
}

func (_c *MockClient_CreateTemplate_Call) Return(_a0 error) *MockClient_CreateTemplate_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateTemplate_Call) RunAndReturn(run func(context.Context, string, *apiv1alpha1.ClusterTemplate) error) *MockClient_CreateTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// CreateTemplateLabels provides a mock function with given fields: ctx, namespace, templateName, newLabels
func (_m *MockClient) CreateTemplateLabels(ctx context.Context, namespace string, templateName string, newLabels map[string]string) error {
	ret := _m.Called(ctx, namespace, templateName, newLabels)

	if len(ret) == 0 {
		panic("no return value specified for CreateTemplateLabels")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string, map[string]string) error); ok {
		r0 = rf(ctx, namespace, templateName, newLabels)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_CreateTemplateLabels_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'CreateTemplateLabels'
type MockClient_CreateTemplateLabels_Call struct {
	*mock.Call
}

// CreateTemplateLabels is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - templateName string
//   - newLabels map[string]string
func (_e *MockClient_Expecter) CreateTemplateLabels(ctx interface{}, namespace interface{}, templateName interface{}, newLabels interface{}) *MockClient_CreateTemplateLabels_Call {
	return &MockClient_CreateTemplateLabels_Call{Call: _e.mock.On("CreateTemplateLabels", ctx, namespace, templateName, newLabels)}
}

func (_c *MockClient_CreateTemplateLabels_Call) Run(run func(ctx context.Context, namespace string, templateName string, newLabels map[string]string)) *MockClient_CreateTemplateLabels_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string), args[3].(map[string]string))
	})
	return _c
}

func (_c *MockClient_CreateTemplateLabels_Call) Return(_a0 error) *MockClient_CreateTemplateLabels_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_CreateTemplateLabels_Call) RunAndReturn(run func(context.Context, string, string, map[string]string) error) *MockClient_CreateTemplateLabels_Call {
	_c.Call.Return(run)
	return _c
}

// DefaultTemplate provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DefaultTemplate(ctx context.Context, namespace string) (apiv1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for DefaultTemplate")
	}

	var r0 apiv1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) (apiv1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) apiv1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Get(0).(apiv1alpha1.ClusterTemplate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DefaultTemplate_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DefaultTemplate'
type MockClient_DefaultTemplate_Call struct {
	*mock.Call
}

// DefaultTemplate is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *MockClient_Expecter) DefaultTemplate(ctx interface{}, namespace interface{}) *MockClient_DefaultTemplate_Call {
	return &MockClient_DefaultTemplate_Call{Call: _e.mock.On("DefaultTemplate", ctx, namespace)}
}

func (_c *MockClient_DefaultTemplate_Call) Run(run func(ctx context.Context, namespace string)) *MockClient_DefaultTemplate_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_DefaultTemplate_Call) Return(_a0 apiv1alpha1.ClusterTemplate, _a1 error) *MockClient_DefaultTemplate_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DefaultTemplate_Call) RunAndReturn(run func(context.Context, string) (apiv1alpha1.ClusterTemplate, error)) *MockClient_DefaultTemplate_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteClusters provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteClusters(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for DeleteClusters")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteClusters_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteClusters'
type MockClient_DeleteClusters_Call struct {
	*mock.Call
}

// DeleteClusters is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *MockClient_Expecter) DeleteClusters(ctx interface{}, namespace interface{}) *MockClient_DeleteClusters_Call {
	return &MockClient_DeleteClusters_Call{Call: _e.mock.On("DeleteClusters", ctx, namespace)}
}

func (_c *MockClient_DeleteClusters_Call) Run(run func(ctx context.Context, namespace string)) *MockClient_DeleteClusters_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_DeleteClusters_Call) Return(_a0 error) *MockClient_DeleteClusters_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteClusters_Call) RunAndReturn(run func(context.Context, string) error) *MockClient_DeleteClusters_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteNamespace provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteNamespace(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for DeleteNamespace")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteNamespace_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteNamespace'
type MockClient_DeleteNamespace_Call struct {
	*mock.Call
}

// DeleteNamespace is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *MockClient_Expecter) DeleteNamespace(ctx interface{}, namespace interface{}) *MockClient_DeleteNamespace_Call {
	return &MockClient_DeleteNamespace_Call{Call: _e.mock.On("DeleteNamespace", ctx, namespace)}
}

func (_c *MockClient_DeleteNamespace_Call) Run(run func(ctx context.Context, namespace string)) *MockClient_DeleteNamespace_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_DeleteNamespace_Call) Return(_a0 error) *MockClient_DeleteNamespace_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteNamespace_Call) RunAndReturn(run func(context.Context, string) error) *MockClient_DeleteNamespace_Call {
	_c.Call.Return(run)
	return _c
}

// DeleteTemplates provides a mock function with given fields: ctx, namespace
func (_m *MockClient) DeleteTemplates(ctx context.Context, namespace string) error {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for DeleteTemplates")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, string) error); ok {
		r0 = rf(ctx, namespace)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_DeleteTemplates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DeleteTemplates'
type MockClient_DeleteTemplates_Call struct {
	*mock.Call
}

// DeleteTemplates is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *MockClient_Expecter) DeleteTemplates(ctx interface{}, namespace interface{}) *MockClient_DeleteTemplates_Call {
	return &MockClient_DeleteTemplates_Call{Call: _e.mock.On("DeleteTemplates", ctx, namespace)}
}

func (_c *MockClient_DeleteTemplates_Call) Run(run func(ctx context.Context, namespace string)) *MockClient_DeleteTemplates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_DeleteTemplates_Call) Return(_a0 error) *MockClient_DeleteTemplates_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_DeleteTemplates_Call) RunAndReturn(run func(context.Context, string) error) *MockClient_DeleteTemplates_Call {
	_c.Call.Return(run)
	return _c
}

// DockerMachine provides a mock function with given fields: ctx, namespace, providerMachineName
func (_m *MockClient) DockerMachine(ctx context.Context, namespace string, providerMachineName string) (apiv1beta1.DockerMachine, error) {
	ret := _m.Called(ctx, namespace, providerMachineName)

	if len(ret) == 0 {
		panic("no return value specified for DockerMachine")
	}

	var r0 apiv1beta1.DockerMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (apiv1beta1.DockerMachine, error)); ok {
		return rf(ctx, namespace, providerMachineName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) apiv1beta1.DockerMachine); ok {
		r0 = rf(ctx, namespace, providerMachineName)
	} else {
		r0 = ret.Get(0).(apiv1beta1.DockerMachine)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, providerMachineName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DockerMachine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DockerMachine'
type MockClient_DockerMachine_Call struct {
	*mock.Call
}

// DockerMachine is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - providerMachineName string
func (_e *MockClient_Expecter) DockerMachine(ctx interface{}, namespace interface{}, providerMachineName interface{}) *MockClient_DockerMachine_Call {
	return &MockClient_DockerMachine_Call{Call: _e.mock.On("DockerMachine", ctx, namespace, providerMachineName)}
}

func (_c *MockClient_DockerMachine_Call) Run(run func(ctx context.Context, namespace string, providerMachineName string)) *MockClient_DockerMachine_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DockerMachine_Call) Return(_a0 apiv1beta1.DockerMachine, _a1 error) *MockClient_DockerMachine_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DockerMachine_Call) RunAndReturn(run func(context.Context, string, string) (apiv1beta1.DockerMachine, error)) *MockClient_DockerMachine_Call {
	_c.Call.Return(run)
	return _c
}

// DockerMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) DockerMachines(ctx context.Context, namespace string, clusterName string) ([]apiv1beta1.DockerMachine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	if len(ret) == 0 {
		panic("no return value specified for DockerMachines")
	}

	var r0 []apiv1beta1.DockerMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]apiv1beta1.DockerMachine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []apiv1beta1.DockerMachine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]apiv1beta1.DockerMachine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_DockerMachines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'DockerMachines'
type MockClient_DockerMachines_Call struct {
	*mock.Call
}

// DockerMachines is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - clusterName string
func (_e *MockClient_Expecter) DockerMachines(ctx interface{}, namespace interface{}, clusterName interface{}) *MockClient_DockerMachines_Call {
	return &MockClient_DockerMachines_Call{Call: _e.mock.On("DockerMachines", ctx, namespace, clusterName)}
}

func (_c *MockClient_DockerMachines_Call) Run(run func(ctx context.Context, namespace string, clusterName string)) *MockClient_DockerMachines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_DockerMachines_Call) Return(_a0 []apiv1beta1.DockerMachine, _a1 error) *MockClient_DockerMachines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_DockerMachines_Call) RunAndReturn(run func(context.Context, string, string) ([]apiv1beta1.DockerMachine, error)) *MockClient_DockerMachines_Call {
	_c.Call.Return(run)
	return _c
}

// Dynamic provides a mock function with no fields
func (_m *MockClient) Dynamic() dynamic.Interface {
	ret := _m.Called()

	if len(ret) == 0 {
		panic("no return value specified for Dynamic")
	}

	var r0 dynamic.Interface
	if rf, ok := ret.Get(0).(func() dynamic.Interface); ok {
		r0 = rf()
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(dynamic.Interface)
		}
	}

	return r0
}

// MockClient_Dynamic_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Dynamic'
type MockClient_Dynamic_Call struct {
	*mock.Call
}

// Dynamic is a helper method to define mock.On call
func (_e *MockClient_Expecter) Dynamic() *MockClient_Dynamic_Call {
	return &MockClient_Dynamic_Call{Call: _e.mock.On("Dynamic")}
}

func (_c *MockClient_Dynamic_Call) Run(run func()) *MockClient_Dynamic_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run()
	})
	return _c
}

func (_c *MockClient_Dynamic_Call) Return(_a0 dynamic.Interface) *MockClient_Dynamic_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_Dynamic_Call) RunAndReturn(run func() dynamic.Interface) *MockClient_Dynamic_Call {
	_c.Call.Return(run)
	return _c
}

// GetCached provides a mock function with given fields: ctx, resourceSchema, namespace, name
func (_m *MockClient) GetCached(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace string, name string) (*unstructured.Unstructured, error) {
	ret := _m.Called(ctx, resourceSchema, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetCached")
	}

	var r0 *unstructured.Unstructured
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, string) (*unstructured.Unstructured, error)); ok {
		return rf(ctx, resourceSchema, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, string) *unstructured.Unstructured); ok {
		r0 = rf(ctx, resourceSchema, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*unstructured.Unstructured)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.GroupVersionResource, string, string) error); ok {
		r1 = rf(ctx, resourceSchema, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetCached_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCached'
type MockClient_GetCached_Call struct {
	*mock.Call
}

// GetCached is a helper method to define mock.On call
//   - ctx context.Context
//   - resourceSchema schema.GroupVersionResource
//   - namespace string
//   - name string
func (_e *MockClient_Expecter) GetCached(ctx interface{}, resourceSchema interface{}, namespace interface{}, name interface{}) *MockClient_GetCached_Call {
	return &MockClient_GetCached_Call{Call: _e.mock.On("GetCached", ctx, resourceSchema, namespace, name)}
}

func (_c *MockClient_GetCached_Call) Run(run func(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace string, name string)) *MockClient_GetCached_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(schema.GroupVersionResource), args[2].(string), args[3].(string))
	})
	return _c
}

func (_c *MockClient_GetCached_Call) Return(_a0 *unstructured.Unstructured, _a1 error) *MockClient_GetCached_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetCached_Call) RunAndReturn(run func(context.Context, schema.GroupVersionResource, string, string) (*unstructured.Unstructured, error)) *MockClient_GetCached_Call {
	_c.Call.Return(run)
	return _c
}

// GetCluster provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) GetCluster(ctx context.Context, namespace string, name string) (*v1beta1.Cluster, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for GetCluster")
	}

	var r0 *v1beta1.Cluster
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (*v1beta1.Cluster, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) *v1beta1.Cluster); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*v1beta1.Cluster)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetCluster_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetCluster'
type MockClient_GetCluster_Call struct {
	*mock.Call
}

// GetCluster is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - name string
func (_e *MockClient_Expecter) GetCluster(ctx interface{}, namespace interface{}, name interface{}) *MockClient_GetCluster_Call {
	return &MockClient_GetCluster_Call{Call: _e.mock.On("GetCluster", ctx, namespace, name)}
}

func (_c *MockClient_GetCluster_Call) Run(run func(ctx context.Context, namespace string, name string)) *MockClient_GetCluster_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetCluster_Call) Return(_a0 *v1beta1.Cluster, _a1 error) *MockClient_GetCluster_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetCluster_Call) RunAndReturn(run func(context.Context, string, string) (*v1beta1.Cluster, error)) *MockClient_GetCluster_Call {
	_c.Call.Return(run)
	return _c
}

// GetMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) GetMachines(ctx context.Context, namespace string, clusterName string) ([]v1beta1.Machine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	if len(ret) == 0 {
		panic("no return value specified for GetMachines")
	}

	var r0 []v1beta1.Machine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]v1beta1.Machine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []v1beta1.Machine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1beta1.Machine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_GetMachines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'GetMachines'
type MockClient_GetMachines_Call struct {
	*mock.Call
}

// GetMachines is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - clusterName string
func (_e *MockClient_Expecter) GetMachines(ctx interface{}, namespace interface{}, clusterName interface{}) *MockClient_GetMachines_Call {
	return &MockClient_GetMachines_Call{Call: _e.mock.On("GetMachines", ctx, namespace, clusterName)}
}

func (_c *MockClient_GetMachines_Call) Run(run func(ctx context.Context, namespace string, clusterName string)) *MockClient_GetMachines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_GetMachines_Call) Return(_a0 []v1beta1.Machine, _a1 error) *MockClient_GetMachines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_GetMachines_Call) RunAndReturn(run func(context.Context, string, string) ([]v1beta1.Machine, error)) *MockClient_GetMachines_Call {
	_c.Call.Return(run)
	return _c
}

// IntelMachine provides a mock function with given fields: ctx, namespace, providerMachineName
func (_m *MockClient) IntelMachine(ctx context.Context, namespace string, providerMachineName string) (v1alpha1.IntelMachine, error) {
	ret := _m.Called(ctx, namespace, providerMachineName)

	if len(ret) == 0 {
		panic("no return value specified for IntelMachine")
	}

	var r0 v1alpha1.IntelMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (v1alpha1.IntelMachine, error)); ok {
		return rf(ctx, namespace, providerMachineName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) v1alpha1.IntelMachine); ok {
		r0 = rf(ctx, namespace, providerMachineName)
	} else {
		r0 = ret.Get(0).(v1alpha1.IntelMachine)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, providerMachineName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_IntelMachine_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IntelMachine'
type MockClient_IntelMachine_Call struct {
	*mock.Call
}

// IntelMachine is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - providerMachineName string
func (_e *MockClient_Expecter) IntelMachine(ctx interface{}, namespace interface{}, providerMachineName interface{}) *MockClient_IntelMachine_Call {
	return &MockClient_IntelMachine_Call{Call: _e.mock.On("IntelMachine", ctx, namespace, providerMachineName)}
}

func (_c *MockClient_IntelMachine_Call) Run(run func(ctx context.Context, namespace string, providerMachineName string)) *MockClient_IntelMachine_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_IntelMachine_Call) Return(_a0 v1alpha1.IntelMachine, _a1 error) *MockClient_IntelMachine_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_IntelMachine_Call) RunAndReturn(run func(context.Context, string, string) (v1alpha1.IntelMachine, error)) *MockClient_IntelMachine_Call {
	_c.Call.Return(run)
	return _c
}

// IntelMachines provides a mock function with given fields: ctx, namespace, clusterName
func (_m *MockClient) IntelMachines(ctx context.Context, namespace string, clusterName string) ([]v1alpha1.IntelMachine, error) {
	ret := _m.Called(ctx, namespace, clusterName)

	if len(ret) == 0 {
		panic("no return value specified for IntelMachines")
	}

	var r0 []v1alpha1.IntelMachine
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) ([]v1alpha1.IntelMachine, error)); ok {
		return rf(ctx, namespace, clusterName)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) []v1alpha1.IntelMachine); ok {
		r0 = rf(ctx, namespace, clusterName)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]v1alpha1.IntelMachine)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, clusterName)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_IntelMachines_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'IntelMachines'
type MockClient_IntelMachines_Call struct {
	*mock.Call
}

// IntelMachines is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - clusterName string
func (_e *MockClient_Expecter) IntelMachines(ctx interface{}, namespace interface{}, clusterName interface{}) *MockClient_IntelMachines_Call {
	return &MockClient_IntelMachines_Call{Call: _e.mock.On("IntelMachines", ctx, namespace, clusterName)}
}

func (_c *MockClient_IntelMachines_Call) Run(run func(ctx context.Context, namespace string, clusterName string)) *MockClient_IntelMachines_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_IntelMachines_Call) Return(_a0 []v1alpha1.IntelMachine, _a1 error) *MockClient_IntelMachines_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_IntelMachines_Call) RunAndReturn(run func(context.Context, string, string) ([]v1alpha1.IntelMachine, error)) *MockClient_IntelMachines_Call {
	_c.Call.Return(run)
	return _c
}

// ListCached provides a mock function with given fields: ctx, resourceSchema, namespace, listOptions
func (_m *MockClient) ListCached(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace string, listOptions v1.ListOptions) (*unstructured.UnstructuredList, error) {
	ret := _m.Called(ctx, resourceSchema, namespace, listOptions)

	if len(ret) == 0 {
		panic("no return value specified for ListCached")
	}

	var r0 *unstructured.UnstructuredList
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) (*unstructured.UnstructuredList, error)); ok {
		return rf(ctx, resourceSchema, namespace, listOptions)
	}
	if rf, ok := ret.Get(0).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) *unstructured.UnstructuredList); ok {
		r0 = rf(ctx, resourceSchema, namespace, listOptions)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*unstructured.UnstructuredList)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) error); ok {
		r1 = rf(ctx, resourceSchema, namespace, listOptions)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_ListCached_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'ListCached'
type MockClient_ListCached_Call struct {
	*mock.Call
}

// ListCached is a helper method to define mock.On call
//   - ctx context.Context
//   - resourceSchema schema.GroupVersionResource
//   - namespace string
//   - listOptions v1.ListOptions
func (_e *MockClient_Expecter) ListCached(ctx interface{}, resourceSchema interface{}, namespace interface{}, listOptions interface{}) *MockClient_ListCached_Call {
	return &MockClient_ListCached_Call{Call: _e.mock.On("ListCached", ctx, resourceSchema, namespace, listOptions)}
}

func (_c *MockClient_ListCached_Call) Run(run func(ctx context.Context, resourceSchema schema.GroupVersionResource, namespace string, listOptions v1.ListOptions)) *MockClient_ListCached_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(schema.GroupVersionResource), args[2].(string), args[3].(v1.ListOptions))
	})
	return _c
}

func (_c *MockClient_ListCached_Call) Return(_a0 *unstructured.UnstructuredList, _a1 error) *MockClient_ListCached_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_ListCached_Call) RunAndReturn(run func(context.Context, schema.GroupVersionResource, string, v1.ListOptions) (*unstructured.UnstructuredList, error)) *MockClient_ListCached_Call {
	_c.Call.Return(run)
	return _c
}

// StartInformers provides a mock function with given fields: ctx, resources
func (_m *MockClient) StartInformers(ctx context.Context, resources []schema.GroupVersionResource) error {
	ret := _m.Called(ctx, resources)

	if len(ret) == 0 {
		panic("no return value specified for StartInformers")
	}

	var r0 error
	if rf, ok := ret.Get(0).(func(context.Context, []schema.GroupVersionResource) error); ok {
		r0 = rf(ctx, resources)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// MockClient_StartInformers_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'StartInformers'
type MockClient_StartInformers_Call struct {
	*mock.Call
}

// StartInformers is a helper method to define mock.On call
//   - ctx context.Context
//   - resources []schema.GroupVersionResource
func (_e *MockClient_Expecter) StartInformers(ctx interface{}, resources interface{}) *MockClient_StartInformers_Call {
	return &MockClient_StartInformers_Call{Call: _e.mock.On("StartInformers", ctx, resources)}
}

func (_c *MockClient_StartInformers_Call) Run(run func(ctx context.Context, resources []schema.GroupVersionResource)) *MockClient_StartInformers_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].([]schema.GroupVersionResource))
	})
	return _c
}

func (_c *MockClient_StartInformers_Call) Return(_a0 error) *MockClient_StartInformers_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *MockClient_StartInformers_Call) RunAndReturn(run func(context.Context, []schema.GroupVersionResource) error) *MockClient_StartInformers_Call {
	_c.Call.Return(run)
	return _c
}

// Template provides a mock function with given fields: ctx, namespace, name
func (_m *MockClient) Template(ctx context.Context, namespace string, name string) (apiv1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace, name)

	if len(ret) == 0 {
		panic("no return value specified for Template")
	}

	var r0 apiv1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string, string) (apiv1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace, name)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string, string) apiv1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace, name)
	} else {
		r0 = ret.Get(0).(apiv1alpha1.ClusterTemplate)
	}

	if rf, ok := ret.Get(1).(func(context.Context, string, string) error); ok {
		r1 = rf(ctx, namespace, name)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Template_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Template'
type MockClient_Template_Call struct {
	*mock.Call
}

// Template is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
//   - name string
func (_e *MockClient_Expecter) Template(ctx interface{}, namespace interface{}, name interface{}) *MockClient_Template_Call {
	return &MockClient_Template_Call{Call: _e.mock.On("Template", ctx, namespace, name)}
}

func (_c *MockClient_Template_Call) Run(run func(ctx context.Context, namespace string, name string)) *MockClient_Template_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string), args[2].(string))
	})
	return _c
}

func (_c *MockClient_Template_Call) Return(_a0 apiv1alpha1.ClusterTemplate, _a1 error) *MockClient_Template_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Template_Call) RunAndReturn(run func(context.Context, string, string) (apiv1alpha1.ClusterTemplate, error)) *MockClient_Template_Call {
	_c.Call.Return(run)
	return _c
}

// Templates provides a mock function with given fields: ctx, namespace
func (_m *MockClient) Templates(ctx context.Context, namespace string) ([]apiv1alpha1.ClusterTemplate, error) {
	ret := _m.Called(ctx, namespace)

	if len(ret) == 0 {
		panic("no return value specified for Templates")
	}

	var r0 []apiv1alpha1.ClusterTemplate
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, string) ([]apiv1alpha1.ClusterTemplate, error)); ok {
		return rf(ctx, namespace)
	}
	if rf, ok := ret.Get(0).(func(context.Context, string) []apiv1alpha1.ClusterTemplate); ok {
		r0 = rf(ctx, namespace)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]apiv1alpha1.ClusterTemplate)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, string) error); ok {
		r1 = rf(ctx, namespace)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// MockClient_Templates_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Templates'
type MockClient_Templates_Call struct {
	*mock.Call
}

// Templates is a helper method to define mock.On call
//   - ctx context.Context
//   - namespace string
func (_e *MockClient_Expecter) Templates(ctx interface{}, namespace interface{}) *MockClient_Templates_Call {
	return &MockClient_Templates_Call{Call: _e.mock.On("Templates", ctx, namespace)}
}

func (_c *MockClient_Templates_Call) Run(run func(ctx context.Context, namespace string)) *MockClient_Templates_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(string))
	})
	return _c
}

func (_c *MockClient_Templates_Call) Return(_a0 []apiv1alpha1.ClusterTemplate, _a1 error) *MockClient_Templates_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *MockClient_Templates_Call) RunAndReturn(run func(context.Context, string) ([]apiv1alpha1.ClusterTemplate, error)) *MockClient_Templates_Call {
	_c.Call.Return(run)
	return _c
}

// NewMockClient creates a new instance of MockClient. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewMockClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *MockClient {
	mock := &MockClient{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
