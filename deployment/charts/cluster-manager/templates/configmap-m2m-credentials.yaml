# SPDX-FileCopyrightText: (C) 2025 Intel Corporation
# SPDX-License-Identifier: Apache-2.0
---
{{- if .Values.credentialsM2M.enabled }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "cluster-manager.fullname" . }}-credentials-script
  namespace: {{ .Release.Namespace }}
  labels:
    {{- include "cluster-manager.labels" . | nindent 4 }}
data:
  credentials-m2m.sh: |
    #!/bin/bash
    set -euo pipefail
    # Helm values
    VAULT_ADDR="http://{{ .Values.credentialsM2M.vault.service }}:{{ .Values.credentialsM2M.vault.port }}"
    KEYCLOAK_URL="http://{{ .Values.credentialsM2M.keycloak.service }}:{{ .Values.credentialsM2M.keycloak.port }}"
    KEYCLOAK_REALM="{{ .Values.credentialsM2M.keycloak.realm }}"
    CLIENT_ID="{{ .Values.credentialsM2M.keycloak.clientId }}"
    SECRET_PATH="{{ .Values.credentialsM2M.vault.secretPath }}"
    RETRY_ATTEMPTS={{ .Values.credentialsM2M.job.retryAttempts }}
    RETRY_DELAY={{ .Values.credentialsM2M.job.retryDelay }}
    K8S_API_SERVER="https://kubernetes.default.svc"
    K8S_CA_CERT="/var/run/secrets/kubernetes.io/serviceaccount/ca.crt"
    KEYCLOAK_SECRET_NAMESPACE="{{ .Values.credentialsM2M.keycloak.adminSecretNamespace }}"
    KEYCLOAK_SECRET_NAME="{{ .Values.credentialsM2M.keycloak.adminSecretName }}"

    # service account token for Vault authn
    SA_TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

    # Security: Clean up sensitive variables on exit
    cleanup_sensitive_vars() {
        unset root_token VAULT_TOKEN ADMIN_PASS KC_ADMIN_TOKEN CLIENT_SECRET SA_TOKEN 2>/dev/null || true
    }

    wait_for_istio_sidecar() {
        local max_wait=60
        local wait_time=0
        log "Waiting for Istio sidecar to be ready..."
        while [ $wait_time -lt $max_wait ]; do
            if curl -s -f http://127.0.0.1:15021/healthz/ready >/dev/null 2>&1; then
                log "Istio sidecar is ready"
                return 0
            fi
            log "Waiting for Istio sidecar... ($wait_time/$max_wait seconds)"
            sleep 2
            wait_time=$((wait_time + 2))
        done
        log "WARNING: Istio sidecar not ready after ${max_wait}s, continuing anyway"
        return 1
    }

    # Istio sidecar shutdown function
    shutdown_istio_sidecar() {
        if curl -s -f http://127.0.0.1:15020/healthz/ready >/dev/null 2>&1; then
            log "Shutting down Istio sidecar..."
            curl -s -X POST http://127.0.0.1:15000/quitquitquit >/dev/null 2>&1 || true
        fi
    }

    trap 'cleanup_sensitive_vars; shutdown_istio_sidecar' EXIT

    log() {
        echo "[$(date -Iseconds)] $*" >&2
    }

    retry_with_backoff() {
        local attempt=1
        local cmd_description="$1"  # First argument is description
        shift  # Remove description from arguments, leaving the actual command
        
        log "Starting retry for: $cmd_description (max attempts: $RETRY_ATTEMPTS)"
        
        while [ $attempt -le $RETRY_ATTEMPTS ]; do
            log "Attempting $cmd_description (attempt $attempt/$RETRY_ATTEMPTS)"
            
            if "$@"; then
                log "SUCCESS: $cmd_description completed on attempt $attempt"
                return 0
            fi
            
            if [ $attempt -lt $RETRY_ATTEMPTS ]; then
                log "FAILED: $cmd_description attempt $attempt failed - retrying in ${RETRY_DELAY}s..."
                sleep $RETRY_DELAY
            else
                log "FAILED: $cmd_description attempt $attempt failed - no more retries"
            fi
            
            attempt=$((attempt + 1))
        done
        
        log "ERROR: $cmd_description failed after $RETRY_ATTEMPTS attempts"
        return 1
    }

    ensure_vault_role_and_policy() {
        log "checking if cluster-manager vault role and policy exist"

        # try to get root token from vault-keys secret
        local vault_keys_response=$(curl -s -f \
            --header "Authorization: Bearer $SA_TOKEN" \
            --cacert "$K8S_CA_CERT" \
            "$K8S_API_SERVER/api/v1/namespaces/orch-platform/secrets/vault-keys" 2>/dev/null)

        if [ $? -ne 0 ]; then
            log "WARNING: unable to access vault-keys secret, assuming role exists"
            return 0
        fi

        local vault_keys_data=$(echo "$vault_keys_response" | jq -r '.data["vault-keys"]' | base64 -d 2>/dev/null)
        if [ $? -ne 0 ] || [ -z "$vault_keys_data" ]; then
            log "WARNING: unable to decode vault-keys, assuming role exists"
            return 0
        fi

        local root_token=$(echo "$vault_keys_data" | jq -r '.root_token' 2>/dev/null)
        if [ -z "$root_token" ] || [ "$root_token" = "null" ]; then
            log "WARNING: no root token found, assuming role exists"
            return 0
        fi

        # check if role exists
        local role_check=$(curl -s -w "%{http_code}" \
            --header "X-Vault-Token: $root_token" \
            "$VAULT_ADDR/v1/auth/kubernetes/role/cluster-manager" \
            --output /dev/null)

        if [ "$role_check" = "200" ]; then
            log "cluster-manager role already exists"
            unset root_token  # clean up sensitive variable
            return 0
        fi

        log "cluster-manager role not found, creating role and policy"

        # create policy
        local policy_data='{"policy":"path \"secret/data/co-manager-m2m-client-secret\" {\n  capabilities = [\"create\", \"read\", \"update\"]\n}\npath \"secret/metadata/co-manager-m2m-client-secret\" {\n  capabilities = [\"list\", \"read\"]\n}"}'
        local policy_response=$(curl -s -w "%{http_code}" \
            --request PUT \
            --header "X-Vault-Token: $root_token" \
            --header "Content-Type: application/json" \
            --data "$policy_data" \
            "$VAULT_ADDR/v1/sys/policies/acl/cluster-manager")

        local policy_code="${policy_response: -3}"
        if [ "$policy_code" != "204" ]; then
            log "ERROR: failed to create cluster-manager policy (HTTP $policy_code)"
            return 1
        fi

        # create role
        local role_data='{"bound_service_account_names":["cluster-manager"],"bound_service_account_namespaces":["orch-cluster"],"policies":["cluster-manager"],"ttl":"1h","max_ttl":"1h"}'
        local role_response=$(curl -s -w "%{http_code}" \
            --request POST \
            --header "X-Vault-Token: $root_token" \
            --header "Content-Type: application/json" \
            --data "$role_data" \
            "$VAULT_ADDR/v1/auth/kubernetes/role/cluster-manager")

        local role_code="${role_response: -3}"
        if [ "$role_code" != "204" ]; then
            log "ERROR: failed to create cluster-manager role (HTTP $role_code)"
            unset root_token  # clean up sensitive variable
            return 1
        fi

        log "SUCCESS: created cluster-manager role and policy"
        unset root_token  # clean up sensitive variable
        return 0
    }

    authenticate_vault() {
        log "authenticating with vault"
        local auth_response=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            --request POST \
            --header "Content-Type: application/json" \
            --data "{\"jwt\": \"$SA_TOKEN\", \"role\": \"cluster-manager\"}" \
            "$VAULT_ADDR/v1/auth/kubernetes/login")

        local http_code="${auth_response##*HTTPSTATUS:}"
        local response_body="${auth_response%HTTPSTATUS:*}"

        if [ "$http_code" != "200" ]; then
            log "ERROR: vault authentication failed (HTTP $http_code)"
            return 1
        fi

        VAULT_TOKEN=$(echo "$response_body" | jq -r '.auth.client_token')
        if [ "$VAULT_TOKEN" = "null" ] || [ -z "$VAULT_TOKEN" ]; then
            log "ERROR: failed to extract vault token"
            return 1
        fi

        return 0
    }

    get_keycloak_admin_password() {
        local secret_response=$(retry_with_backoff "Keycloak admin credentials request" curl -s -f \
            --header "Authorization: Bearer $SA_TOKEN" \
            --cacert "$K8S_CA_CERT" \
            "$K8S_API_SERVER/api/v1/namespaces/$KEYCLOAK_SECRET_NAMESPACE/secrets/$KEYCLOAK_SECRET_NAME")

        if [ $? -ne 0 ]; then
            log "ERROR: failed to get keycloak admin secret from Kubernetes API"
            return 1
        fi

        # Extract and decode base64 password
        local admin_pass_b64=$(echo "$secret_response" | jq -r '.data["admin-password"] // .data.password // empty')
        if [ -z "$admin_pass_b64" ] || [ "$admin_pass_b64" = "null" ]; then
            log "ERROR: password field not found in secret. Available fields:"
            echo "$secret_response" | jq -r '.data | keys[]' >&2
            return 1
        fi

        ADMIN_PASS=$(echo "$admin_pass_b64" | base64 -d)
        if [ -z "$ADMIN_PASS" ]; then
            log "ERROR: failed to decode admin password"
            return 1
        fi

        return 0
    }

    get_keycloak_admin_token() {
        local admin_user="admin"
        if ! get_keycloak_admin_password; then
            log "ERROR: failed to get Keycloak admin password"
            return 1
        fi

        local token_response=$(retry_with_backoff "getting keycloak admin token" sh -c "
            curl -s -f \
                --request POST \
                --header 'Content-Type: application/x-www-form-urlencoded' \
                --data-urlencode 'grant_type=password' \
                --data-urlencode 'client_id=admin-cli' \
                --data-urlencode 'username=$admin_user' \
                --data-urlencode 'password=$ADMIN_PASS' \
                '$KEYCLOAK_URL/realms/master/protocol/openid-connect/token'
        ")

        if [ $? -ne 0 ]; then
            log "ERROR: failed to get keycloak admin token"
            unset ADMIN_PASS  # clean up sensitive variable
            return 1
        fi

        KC_ADMIN_TOKEN=$(echo "$token_response" | jq -r '.access_token')
        if [ "$KC_ADMIN_TOKEN" = "null" ] || [ -z "$KC_ADMIN_TOKEN" ]; then
            log "ERROR: failed to extract keycloak admin token"
            unset ADMIN_PASS  # clean up sensitive variable
            return 1
        fi

        unset ADMIN_PASS  # clean up sensitive variable after use
        return 0
    }

    check_existing_secret() {
        local secret_response=$(curl -s -w "%{http_code}" \
            --header "X-Vault-Token: $VAULT_TOKEN" \
            "$VAULT_ADDR/v1/$SECRET_PATH")

        local http_code="${secret_response: -3}"

        if [ "$http_code" = "200" ]; then
            return 0
        elif [ "$http_code" = "404" ]; then
            log "secret not found, proceeding with extraction"
            return 1
        else
            log "ERROR: response code $http_code when checking vault secret"
            return 1
        fi
    }

    extract_client_credentials() {
        # get client UUID
        local clients_response=$(retry_with_backoff "extract client cred" curl -s -f \
            --header "Authorization: Bearer $KC_ADMIN_TOKEN" \
            --header "Content-Type: application/json" \
            "$KEYCLOAK_URL/admin/realms/$KEYCLOAK_REALM/clients?clientId=$CLIENT_ID")

        if [ $? -ne 0 ]; then
            log "ERROR: failed to get client list from keycloak"
            return 1
        fi

        local client_uuid=$(echo "$clients_response" | jq -r ".[0].id")
        if [ "$client_uuid" = "null" ] || [ -z "$client_uuid" ]; then
            log "ERROR: co-manager-m2m-client not found in keycloak"
            return 1
        fi

        # get client secret
        local secret_response=$(retry_with_backoff "get client secret" curl -s -f \
            --header "Authorization: Bearer $KC_ADMIN_TOKEN" \
            --header "Content-Type: application/json" \
            "$KEYCLOAK_URL/admin/realms/$KEYCLOAK_REALM/clients/$client_uuid/client-secret")

        if [ $? -ne 0 ]; then
            log "ERROR: failed to get client secret from keycloak"
            return 1
        fi

        CLIENT_SECRET=$(echo "$secret_response" | jq -r '.value')
        if [ "$CLIENT_SECRET" = "null" ] || [ -z "$CLIENT_SECRET" ]; then
            log "ERROR: failed to extract client secret"
            return 1
        fi

        return 0
    }

    store_credentials_in_vault() {
        local vault_data=$(jq -n \
            --arg client_id "$CLIENT_ID" \
            --arg client_secret "$CLIENT_SECRET" \
            '{data: {client_id: $client_id, client_secret: $client_secret}}')

        local store_response=$(curl -s -w "HTTPSTATUS:%{http_code}" \
            --request PUT \
            --header "X-Vault-Token: $VAULT_TOKEN" \
            --header "Content-Type: application/json" \
            --data "$vault_data" \
            "$VAULT_ADDR/v1/$SECRET_PATH")

        local http_code=$(echo "$store_response" | grep -o "HTTPSTATUS:[0-9]*" | cut -d: -f2)
        if [ "$http_code" -ge 200 ] && [ "$http_code" -lt 300 ]; then
            log "SUCCESS: credentials stored in vault at $SECRET_PATH"
            return 0
        else
            log "ERROR: failed to store credentials in vault (HTTP $http_code)"
            return 1
        fi
    }

    main() {
        wait_for_istio_sidecar

        if ! ensure_vault_role_and_policy; then
            log "WARNING: failed to ensure vault role/policy, continuing anyway"
        fi

        if ! authenticate_vault; then
            log "FATAL: vault authn failed"
            exit 1
        fi

        if check_existing_secret; then
            log "job completed successfully"
            exit 0
        fi

        if ! get_keycloak_admin_token; then
            log "FATAL: failed to get keycloak admin token"
            exit 1
        fi

        if ! extract_client_credentials; then
            log "FATAL: failed to extract client credentials"
            exit 1
        fi

        if ! retry_with_backoff "store cred in vault" store_credentials_in_vault; then
            log "FATAL: failed to store credentials in vault"
            exit 1
        fi

        log "job completed successfully"
    }

    main "$@"
{{- end }}
